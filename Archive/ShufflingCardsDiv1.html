<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td>Fox Ciel likes shuffling cards.
She uses a deck with 2N cards, numbered 1 through 2N.
Initially, this deck is sorted: the cards are in the order 1,2,3,...,2N from top to bottom.
<br></br>
Ciel always uses the same procedure when shuffling.
One round of shuffling looks as follows:
<ol>
<li>She splits the deck into two piles: the top N cards will be pile A, the bottom N cards pile B.</li>
<li>She takes pile A and rearranges the cards it contains arbitrarily.</li>
<li>She takes pile B and rearranges the cards it contains arbitrarily.</li>
<li>She interleaves the cards from the two piles, producing a single deck again. More precisely, if pile A has cards A1,A2,...,AN and pile B has cards B1,B2,...,BN then the new deck will be A1,B1,A2,B2,...,AN,BN. (Note that the first card must be from pile A.)</li>
</ol>

For example, let N=2 and suppose that Ciel starts with the sorted deck 1,2,3,4.
After the first round of shuffling, she can produce one of the following four decks:
<ul>
<li>1,3,2,4</li>
<li>1,4,2,3</li>
<li>2,3,1,4</li>
<li>2,4,1,3</li>
</ul>

You are given a vector &lt;int&gt; <b>permutation</b> which contains a permutation of the 2N cards.
Ciel wants to produce this permutation of her deck.
Compute and return the smallest number of rounds of shuffling she has to perform.
(When rearranging a pile during the shuffling, she can always pick the best possible order of those cards.)
If Ciel cannot reach the given permutation by shuffling, return -1 instead.
</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>ShufflingCardsDiv1</td></tr><tr><td>Method:</td><td>shuffle</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int shuffle(vector &lt;int&gt; permutation)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr><tr><td>Stack limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>permutation</b> will contain between 4 and 2000 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>The number of elements in <b>permutation</b> will be even.</td></tr><tr><td align="center" valign="top">-</td><td>The elements of <b>permutation</b> will form a permutation of the numbers 1 through 2N, where 2N is the number of elements in <b>permutation</b>.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,2,3,4}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2">There's no need to shuffle the deck at all.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1,4,3,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">One optimal solution:
<ul>
<li>In the first round, pile A will be 1,2 and pile B will be 3,4. She then merges them to produce the deck 1,3,2,4.</li>
<li>In the second round, pile A will be 1,3 and pile B will be 2,4. She rearranges pile B to 4,2 and then merges the two piles to produce the desired deck 1,4,3,2.</li>
</ul></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{6,3,5,2,4,1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{8,5,4,9,1,7,6,10,3,2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{9,1,7,2,10,3,6,4,8,5}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 4</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
